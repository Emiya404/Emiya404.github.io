<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>建站伊始</title>
    <link href="/2023/12/27/hello-world/"/>
    <url>/2023/12/27/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="博客日记（长期更新中）"><a href="#博客日记（长期更新中）" class="headerlink" title="博客日记（长期更新中）"></a>博客日记（长期更新中）</h1><span id="more"></span><h3 id="2023-12-27"><a href="#2023-12-27" class="headerlink" title="2023-12-27"></a>2023-12-27</h3><p>终于换新了自己的博客建站，在新的时光里，我会加油更新自己的知识，也会不断翻新之前存在错误的博客。<br>站里现有的博客文章都是之前自己原创的，借鉴的时候请拜托写上引用，不排除有一些结论是匆匆得出的暴论，但是那又跟小白有什么关系呢（笑）。<br>新一年的计划是，将学习电子技术的过程与IOT的安全分析结合在一起，跟一些硬件项目同时进行，同时，在软件层面，主要是一些物联协议和漏洞分析技术，文章会尽量写的有逻辑和详细，方便自己看。<br>最后，祝看到这里的小伙伴们能够技术进步，学业有成，脱贫脱单不脱发。  </p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>electron——OC/OD/上下拉/GPIO</title>
    <link href="/2023/09/21/2023-9-21-reverse-for-stm32/"/>
    <url>/2023/09/21/2023-9-21-reverse-for-stm32/</url>
    
    <content type="html"><![CDATA[<p>入坑电子的第一步</p><span id="more"></span><h2 id="一、OC-OD门"><a href="#一、OC-OD门" class="headerlink" title="一、OC&#x2F;OD门"></a>一、OC&#x2F;OD门</h2><p>OC门和OD门都是集成电路中比较重要的简单电路组合，其中，OC门的核心组件是三极管（以NPN三极管为例），信号从基极输入，基极与发射极之间使用电阻连接，集电极作为输出开路。同理，OD门将OC门中的三极管换成MOSEFT即可。  </p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/assets/od.png" width="85%">    <br>    <div style="color:orange;    display: inline-block;    color: #999;    padding: 15px;">od门</div></center>OC门的三极管工作在截至状态或者饱和状态，其输入和输出信号均为数字信号，当输入为高电平时，三极管导通，工作在饱和状态，由于该工作状态的限制，所以集电极和发射极（接地）之间的电压不超过0.3V，可以理解为低电平。而当输入为低电平时，三极管工作在截至状态，此时，输出部分处于高阻态，容易受到外界扰动。  OD门的工作状态与OC门十分相似，且性能在很多情况下好于OC门，在此不作赘述。  ## 二、上下拉电阻以OC门为例，前文提到，在三极管截止时，输出端为高阻态，无法进行稳定的输出，解决该种问题的方法是在输出端（集电极）上连接一个定值电阻，电阻的另一端与Vcc相连，这种连接方式即为上拉电阻。在该种情况下继续分析：当输入为高电平时，集电极和发射极间的电压由于工作状态的限制仍不超过0.3V，而输出低电平；当输入为低电平时，上拉电阻与输出信号的端口内阻串联分压，输出默认为高电平，这就保证了输出为低时高阻态不会出现。  下拉电阻与上拉电阻同理，在信号线上用电阻接地，使信号输出默认为低电平，在此不做赘述。  ## 三、推挽输出推挽输出的电路，由两个相反的MOSEFT构成，PMOS的源级接电源，漏极与NMOS的源极相连，NMOS的漏极接地，输出接到PMOS/NMOS的栅极，输出为NMOS的源极。  <center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/assets/push_pull.png" width="85%">    <br>    <div style="color:orange;    display: inline-block;    color: #999;    padding: 15px;">推挽输出简化电路</div></center>对电路进行分析，当输入为高电平时，NMOS导通，PMOS截止，输出引脚和接地的NMOS栅极同一电平，输出低电平，这种状态是“挽”即从输出拉取电流。  当输入为高电平时，NMOS截止，PMOS导通，Vdd与输出引脚导通，那么输出自然是高电平，这种状态是“推”即向输出推送电流。  ## 四、线与线与是指将多个输出端互联实现按位与的功能，只有全部的输出为高电平时组合输出才为高电平。  对于开漏输出（OC/OD门）而言，任意一个三极管或者NMOS导通，都代表着输出端与地之间导通，仅当两个NMOS都截止时才会输出高电平。  而对于推挽输出而言，当一方输出为0，一方输出为1时，输出为1的一方将通过输出线产生流向输出为0一方NMOS的电流，而此时NMOS是导通的，电阻很小，会有烧坏的风险。  ## 五、GPIO在处理了很多的基本电路知识之后，我们来到了通用输入输出结构，作为发送和接收数字信号或者接收模拟信号的接口，CPU对于GPIO寄存器的操会经过GPIO驱动器映射到GPIO的输出上，下面来分析GPIO的驱动电路。  <center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/assets/GPIO_bit.png" width="85%">    <br>    <div style="color:orange;    display: inline-block;    color: #999;    padding: 15px;">GPIO 位结构</div></center><p>在本次分析时，我们先忽略复用功能输入和复用功能输出，进行最基本的GPIO分析。<br>首先是输出部分，输出数据寄存器的数据位与输出控制相连，输入给推挽输出的输入端（更进一步，输出控制可以控制推挽输出中MOS管是否工作，这样就可以将输出在推挽和开漏输出间进行转换），最后经过保护二极管作为IO引脚的输出。<br>其次是输入部分，输入信号经过二极管保护与上下拉电阻的控制后，是一个施密特触发器，只在电压高于高电平或者低于低电平后开始跳变，可以防止抖动，失真等等情况，如果是模拟输入，该触发器会关闭，GPIO直接读取模拟输入。<br>从以上的分析中我们可以看出，GPIO的配置不止需要数据，更需要确定其输入输出的选项功能。<br>需要确定的部分如下：  </p><ul><li>该引脚是否输入？</li><li>该引脚如果不输入，那么输出模式是开漏还是推挽？</li><li>该引脚如果输入，那么输入是上拉，下拉，浮空，还是模拟？</li></ul><p>在确定这些之后，我们只需要对数据寄存器进行读写就可以实现利用GPIO信号控制外设了。  </p><h2 id="六、stm32-GPIO标准库分析及使用"><a href="#六、stm32-GPIO标准库分析及使用" class="headerlink" title="六、stm32 GPIO标准库分析及使用"></a>六、stm32 GPIO标准库分析及使用</h2><p>根据stm32F10X的文档，每个GPI&#x2F;O端口有两个32位配置寄存器(GPIOx_CRL，GPIOx_CRH)，两个32位数据寄存器(GPIOx_IDR和GPIOx_ODR)，一个32位置位&#x2F;复位寄存器(GPIOx_BSRR)，一个16位复位寄存器(GPIOx_BRR)和一个32位锁定寄存器(GPIOx_LCKR)。<br>其中，CR寄存器的MODE负责调整引脚是输出还是输入，如果是输出，输出速率是多少；CR寄存器的CNF负责调整输入的上下拉和模拟，输出的推挽还是开漏。数据寄存器ODR映射到输出，而BSRR和BRR以位操作的方式来置位某一位的输入输出。<br>接下来我们从标准库的源码角度来分析GPIO的操作（对代码做出一系列简化）：  </p><h3 id="RCC-APB2PeriphClockCmd"><a href="#RCC-APB2PeriphClockCmd" class="headerlink" title="RCC_APB2PeriphClockCmd"></a>RCC_APB2PeriphClockCmd</h3><p>当外设时钟没有启用时，软件不能读出外设寄存器的数值，返回的数值始终是0x0,所以首先设置APB2总线的时钟即可，APB2的时钟使能寄存器RCC的每一位都代表一个连接在其上的外设，直接置位之后则可以将其打开，所以，函数传入的其实是一个位图。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">RCC_APB2PeriphClockCmd</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>&#123;<br>  <span class="hljs-keyword">if</span> (NewState != DISABLE)&#123;<br>    RCC-&gt;APB2ENR |= RCC_APB2Periph;<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<br>    RCC-&gt;APB2ENR &amp;= ~RCC_APB2Periph;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="GPIO-Init"><a href="#GPIO-Init" class="headerlink" title="GPIO_Init"></a>GPIO_Init</h3><p>首先，传入的参数分别是GPIO端口的所属，例如GPIOA、GPIOB等等，然后是GPIO的参数，包括具体引脚，MODE和速率。<br>首先是通过结构体提取了MODE部分，该部分包括了寄存器中CNF和MODE的内容，取出与0x10这一位，代表输入&#x2F;输出，如果是输出，则初始化输出速率。（其实除了MODE+CNF的四位，还有剩下的位数是分辨读写和上下拉的，因为上下拉的MODE+CNF相同）  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_Init</span><span class="hljs-params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span>&#123;<br>  <span class="hljs-type">uint32_t</span> currentmode = <span class="hljs-number">0x00</span>, currentpin = <span class="hljs-number">0x00</span>, pinpos = <span class="hljs-number">0x00</span>, pos = <span class="hljs-number">0x00</span>;<br>  <span class="hljs-type">uint32_t</span> tmpreg = <span class="hljs-number">0x00</span>, pinmask = <span class="hljs-number">0x00</span>;<br><br>  currentmode = ((<span class="hljs-type">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0x0F</span>);<br><br>  <span class="hljs-keyword">if</span> ((((<span class="hljs-type">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0x10</span>)) != <span class="hljs-number">0x00</span>)&#123; <br>    currentmode |= (<span class="hljs-type">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Speed;<br>  &#125;<br>  ……<br></code></pre></td></tr></table></figure><p>接下来是初始化前8个针脚，按照位图的方式一个个检查需要初始化的针脚是否存在。如果存在，则找到整个CR寄存器的值中设置对应针脚的地方并清空，然后将提取的MODE的四位（GPIO_MODE&amp;0x0F）用按位或的方式置入即可。  </p><pre><code class="c">  if (((uint32_t)GPIO_InitStruct-&gt;GPIO_Pin &amp; ((uint32_t)0x00FF)) != 0x00)&#123;    tmpreg = GPIOx-&gt;CRL;    for (pinpos = 0x00; pinpos &lt; 0x08; pinpos++)&#123;      pos = ((uint32_t)0x01) &lt;&lt; pinpos;      /* Get the port pins position */      currentpin = (GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos;      if (currentpin == pos)&#123;        pos = pinpos &lt;&lt; 2;        /* Clear the corresponding low control register bits */        pinmask = ((uint32_t)0x0F) &lt;&lt; pos;        tmpreg &amp;= ~pinmask;        /* Write the mode configuration in the corresponding bits */        tmpreg |= (currentmode &lt;&lt; pos);        /* Reset the corresponding ODR bit */        if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)&#123;          GPIOx-&gt;BRR = (((uint32_t)0x01) &lt;&lt; pinpos);        &#125;        else&#123;          /* Set the corresponding ODR bit */          if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)          &#123;            GPIOx-&gt;BSRR = (((uint32_t)0x01) &lt;&lt; pinpos);          &#125;        &#125;      &#125;    &#125;    GPIOx-&gt;CRL = tmpreg;  &#125;&#125;</code></pre><p>设置高位寄存器的方法十分相似，在此不做赘述。<br>GPIO初始化后，便可以通过简单的Set和Reset来输出高低电平了，也可以用来读取电平输入。<br>浅搭个小小的按键控制流水灯：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/assets/led.jpg" width="85%">    <br>    <div style="color:orange;    display: inline-block;    color: #999;    padding: 15px;">GPIO点灯</div></center><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><p>详解：开漏输出与推挽输出 <a href="https://zhuanlan.zhihu.com/p/637921779">https://zhuanlan.zhihu.com/p/637921779</a><br>理一理 OC&#x2F;OD 门、开漏输出、推挽输出等一些相关概念 <a href="https://zhuanlan.zhihu.com/p/555471581">https://zhuanlan.zhihu.com/p/555471581</a><br>江协科技bilibili stm32教程 <a href="https://www.bilibili.com/video/BV1th411z7sn/">https://www.bilibili.com/video/BV1th411z7sn/</a><br>stm32中文手册<br>新概念模拟电路 杨建国</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>electron</category>
      
    </categories>
    
    
    <tags>
      
      <tag>electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>雪夜杂谈——glibc _IO_FILE分析</title>
    <link href="/2023/03/14/2023-3-14-GlibcIO/"/>
    <url>/2023/03/14/2023-3-14-GlibcIO/</url>
    
    <content type="html"><![CDATA[<h2 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h2><p>近年来，对于用户态的堆利用已经十分成熟，但是，在打击点（控制流）方面还是十分单一，不过是<code>malloc hook/free hook</code>的利用（当今能够轻松进行GOT篡改和栈返回地址篡改的题目确实已经很少了），<code>_IO_FILE</code>利用逐渐风靡。<br>说到<code>_IO_FILE</code>，我们其实可以将其当作用户态对于系统调用的包装，它使得开发者能够更加透明地利用系统文件的读写，并且隐藏块读取（设备友好）和字节读取（开发者友好）的冲突。它定义了对于数据的组织和存取方法（只不过更加上层，在用户层的定义封装方法）。<br>以下将对glibc中的<code>fread/fwrite</code>进行简要分析：</p><span id="more"></span><h2 id="fread函数：读入ptr-end之间的数据"><a href="#fread函数：读入ptr-end之间的数据" class="headerlink" title="fread函数：读入ptr-end之间的数据"></a>fread函数：读入ptr-end之间的数据</h2><h3 id="IO-file-xsgetn：根据缓冲区的情况决定如何读入"><a href="#IO-file-xsgetn：根据缓冲区的情况决定如何读入" class="headerlink" title="_IO_file_xsgetn：根据缓冲区的情况决定如何读入"></a>_IO_file_xsgetn：根据缓冲区的情况决定如何读入</h3><p>其调用图如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">_IO_fread<br>    |<span class="hljs-string">----_IO_XSGETN</span><br><span class="hljs-string">            </span>|<span class="hljs-string">----_IO_file_xsgetn</span><br><span class="hljs-string">                        </span>|<span class="hljs-string">----_IO_doallocbuf</span><br><span class="hljs-string">                        </span>|<span class="hljs-string">           </span>|<span class="hljs-string">----malloc</span><br><span class="hljs-string">                        </span>|<span class="hljs-string">----_IO_new_file_underflow</span><br><span class="hljs-string">                                    </span>|<span class="hljs-string">----SYSREAD</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_size_t _IO_file_xsgetn (_IO_FILE *fp, <span class="hljs-type">void</span> *data, _IO_size_t n)<br>&#123;<br>  _IO_size_t want, have;<br>  _IO_ssize_t count;<br>  <span class="hljs-type">char</span> *s = data;<br>  want = n;<br>  <span class="hljs-keyword">if</span> (fp-&gt;_IO_buf_base == <span class="hljs-literal">NULL</span>)<br>  &#123;<br>      <span class="hljs-comment">//alloc the buffer</span><br>      _IO_doallocbuf (fp);<br>  &#125;<br><br>  <span class="hljs-keyword">while</span> (want &gt; <span class="hljs-number">0</span>)<br>  &#123;<br>    have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;<br>    <span class="hljs-comment">//enough data for request-&gt;copy all the data to user</span><br>    <span class="hljs-keyword">if</span> (want &lt;= have)<br>    &#123;<br>      <span class="hljs-built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);<br>      fp-&gt;_IO_read_ptr += want;<br>      want = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>    <span class="hljs-comment">//not enough,read the remainder first</span><br>      <span class="hljs-keyword">if</span> (have &gt; <span class="hljs-number">0</span>)<br>      &#123;<br>        <span class="hljs-built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, have);<br>        s += have;<br>        want -= have;<br>        fp-&gt;_IO_read_ptr += have;<br>      &#125;<br>      <span class="hljs-comment">/* If we now want less than a buffer, underflow and repeat</span><br><span class="hljs-comment">         the copy.  Otherwise, _IO_SYSREAD directly to</span><br><span class="hljs-comment">         the user buffer. */</span><br>      <span class="hljs-keyword">if</span> (fp-&gt;_IO_buf_base<br>          &amp;&amp; want &lt; (<span class="hljs-type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))<br>      &#123;<br>          <span class="hljs-keyword">if</span> (__underflow (fp) == EOF)<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      <span class="hljs-comment">/* These must be set before the sysread as we might longjmp out</span><br><span class="hljs-comment">         waiting for input. */</span><br>      _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);<br>      _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);<br><br>      <span class="hljs-comment">/* Try to maintain alignment: read a whole number of blocks.  */</span><br>      count = want;<br>      <span class="hljs-keyword">if</span> (fp-&gt;_IO_buf_base)<br>      &#123;<br>        _IO_size_t block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;<br>        <span class="hljs-keyword">if</span> (block_size &gt;= <span class="hljs-number">128</span>)<br>          count -= want % block_size;<br>      &#125;<br><br>      count = _IO_SYSREAD (fp, s, count);<br>      <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>)<br>      &#123;<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)<br>          fp-&gt;_flags |= _IO_EOF_SEEN;<br>        <span class="hljs-keyword">else</span><br>          fp-&gt;_flags |= _IO_ERR_SEEN;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br><br>      s += count;<br>      want -= count;<br>      <span class="hljs-keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)<br>        _IO_pos_adjust (fp-&gt;_offset, count);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> n - want;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IO-new-file-underflow"><a href="#IO-new-file-underflow" class="headerlink" title="_IO_new_file_underflow"></a>_IO_new_file_underflow</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> _IO_new_file_underflow (_IO_FILE *fp)  <br>&#123;  <br>  _IO_ssize_t count;  <br>  <span class="hljs-comment">//have read all the remainder</span><br>  <span class="hljs-keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)  <br>    <span class="hljs-keyword">return</span> *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) fp-&gt;_IO_read_ptr;  <br>  <span class="hljs-comment">//if no buffer allocate one!</span><br>  <span class="hljs-keyword">if</span> (fp-&gt;_IO_buf_base == <span class="hljs-literal">NULL</span>)  <br>  &#123;  <br>      _IO_doallocbuf (fp);  <br>  &#125;  <br>  _IO_switch_to_get_mode (fp);  <br>  <span class="hljs-comment">//no remainder,so flush the read buf</span><br>  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;  <br>  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;  <br>  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = fp-&gt;_IO_buf_base;  <br>  <span class="hljs-comment">//read into all the buf</span><br>  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);  <br>  <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>)  <br>  &#123;  <br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)  <br>      fp-&gt;_flags |= _IO_EOF_SEEN;  <br>    <span class="hljs-keyword">else</span>  <br>      fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="hljs-number">0</span>;  <br>  &#125; <br>  <span class="hljs-comment">//data is between read ptr and read end</span><br>  fp-&gt;_IO_read_end += count;   <br>  <span class="hljs-keyword">return</span> *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) fp-&gt;_IO_read_ptr;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>通过上述代码，我们可以发现，fread事实上是对系统调用read的包装，由于需要配合缓冲区而稍显复杂。在<code>_IO_file_xsgetn</code>中，函数先尽力将缓冲中的数据尽数输出，如果仍然达不到需要，则调用<code>_IO_new_file_underflow</code>过程。该过程中因为考虑到缓冲区中已经没有了未读数据，就直接刷新缓冲（将读指针的始末调到缓冲的开始），并在读取之后将<code>_IO_read_end</code>指针指向末尾，完成了新的缓冲状态建立。  </p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/assets/fread.png" width="85%">    <br>    <div style="color:orange;    display: inline-block;    color: #999;    padding: 15px;">fread缓冲区操作</div></center><p>在这种模型中，每次调用<code>fread</code>libc都会假设该文件的缓冲中可能有残留信息，也会在每次读取完成后达成该种状态，即：通过系统调用按用户需要读取，但<code>underflow</code>读取时按缓冲区块读取。  </p><h2 id="fwrite函数：输出base-ptr之间的数据"><a href="#fwrite函数：输出base-ptr之间的数据" class="headerlink" title="fwrite函数：输出base-ptr之间的数据"></a>fwrite函数：输出base-ptr之间的数据</h2><p>其调用图如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">_IO_fwrite<br>    |<span class="hljs-string">----_IO_new_file_xsputn</span><br><span class="hljs-string">                </span>|<span class="hljs-string">----_IO_new_file_overflow</span><br><span class="hljs-string">                </span>|<span class="hljs-string">           </span>|<span class="hljs-string">----_IO_doallocbuf</span><br><span class="hljs-string">                </span>|<span class="hljs-string">           </span>|<span class="hljs-string">          </span>|<span class="hljs-string">----malloc</span><br><span class="hljs-string">                </span>|<span class="hljs-string">           </span>|<span class="hljs-string">----new_do_write</span><br><span class="hljs-string">                </span>|<span class="hljs-string">                      </span>|<span class="hljs-string">----SYSWRITE</span><br><span class="hljs-string">                </span>|<br>                |<span class="hljs-string">----_IO_default_xsputn</span><br><span class="hljs-string">                            </span>|<span class="hljs-string">----_IO_new_file_overflow</span><br></code></pre></td></tr></table></figure><h3 id="IO-xsputn：根据缓冲区的情况决定如何输出"><a href="#IO-xsputn：根据缓冲区的情况决定如何输出" class="headerlink" title="_IO_xsputn：根据缓冲区的情况决定如何输出"></a>_IO_xsputn：根据缓冲区的情况决定如何输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_size_t _IO_new_file_xsputn (_IO_FILE *f, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data, _IO_size_t n)<br>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s = (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *) data;<br>  _IO_size_t to_do = n;<br>  <span class="hljs-type">int</span> must_flush = <span class="hljs-number">0</span>;<br>  _IO_size_t count = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//if there is no needbuf or is putting now-&gt;out put the line</span><br>  <span class="hljs-keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))<br>  &#123;<br>    count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;<br>    <span class="hljs-keyword">if</span> (count &gt;= n)<br>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *p;<br>  <span class="hljs-keyword">for</span> (p = s + n; p &gt; s; )<br>  &#123;<br>    <span class="hljs-keyword">if</span> (*--p == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>&#123;<br>    count = p - s + <span class="hljs-number">1</span>;<br>    must_flush = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br>  &#125;<br>&#125;<br>  &#125;<br>  <span class="hljs-comment">//count means how many empty buf we have and then we will fill it</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)<br>    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;<br><br>  <span class="hljs-comment">//fill the buffer</span><br>  <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>)<br>  &#123;<br>      <span class="hljs-keyword">if</span> (count &gt; to_do)<br>      count = to_do;<br>      <span class="hljs-built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);<br>      f-&gt;_IO_write_ptr += count;<br>      s += count;<br>      to_do -= count;<br>  &#125;<br>  <span class="hljs-comment">//if we fill the whole space but we need more output</span><br>  <span class="hljs-keyword">if</span> (to_do + must_flush &gt; <span class="hljs-number">0</span>)<br>  &#123;<br>      _IO_size_t block_size, do_write;<br>  <span class="hljs-comment">//call overflow to output the buffer now</span><br>      <span class="hljs-keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)<span class="hljs-comment">//end of the file</span><br>    <span class="hljs-keyword">return</span> to_do == <span class="hljs-number">0</span> ? EOF : n - to_do;<br><br>  <span class="hljs-comment">//try to output one by one block</span><br>      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;<br>      do_write = to_do - (block_size &gt;= <span class="hljs-number">128</span> ? to_do % block_size : <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">//output the whole blocks</span><br>      <span class="hljs-keyword">if</span> (do_write)<br>  &#123;<br>    count = new_do_write (f, s, do_write);<br>    to_do -= count;<br>    <span class="hljs-keyword">if</span> (count &lt; do_write)<br>      <span class="hljs-keyword">return</span> n - to_do;<br>  &#125;<br><br>      <span class="hljs-comment">/* Now write out the remainder.  Normally, this will fit in the</span><br><span class="hljs-comment"> buffer, but it&#x27;s somewhat messier for line-buffered files,</span><br><span class="hljs-comment"> so we let _IO_default_xsputn handle the general case. */</span><br>      <span class="hljs-keyword">if</span> (to_do)<br>    to_do -= _IO_default_xsputn (f, s+do_write, to_do);<br>    &#125;<br>  <span class="hljs-keyword">return</span> n - to_do;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IO-default-xsputn：输出剩余部分的函数"><a href="#IO-default-xsputn：输出剩余部分的函数" class="headerlink" title="_IO_default_xsputn：输出剩余部分的函数"></a>_IO_default_xsputn：输出剩余部分的函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_size_t _IO_default_xsputn (_IO_FILE *f, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data, _IO_size_t n)<br>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s = (<span class="hljs-type">char</span> *) data;<br>  _IO_size_t more = n;<br>  <span class="hljs-keyword">for</span> (;;)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)<br>&#123;<br>  <span class="hljs-comment">//get the free space of write buf</span><br>    _IO_size_t count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;<br>    <span class="hljs-keyword">if</span> (count &gt; more)<br>      count = more;<br>  <span class="hljs-comment">//first way to copy</span><br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">20</span>)<br>    &#123;<br>      <span class="hljs-built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);<br>      f-&gt;_IO_write_ptr += count;<br>      s += count;<br>    &#125;<br>  <span class="hljs-comment">//second way to copy</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count)<br>    &#123;<br>      <span class="hljs-type">char</span> *p = f-&gt;_IO_write_ptr;<br>      _IO_ssize_t i;<br>      <span class="hljs-keyword">for</span> (i = count; --i &gt;= <span class="hljs-number">0</span>; )<br>    *p++ = *s++;<br>      f-&gt;_IO_write_ptr = p;<br>    &#125;<br>  <span class="hljs-comment">//finish copy</span><br>    more -= count;<br>&#125;<br>  <span class="hljs-comment">//call syswrite until all the needs are done of file end</span><br>    <span class="hljs-keyword">if</span> (more == <span class="hljs-number">0</span> || _IO_OVERFLOW (f, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>) *s++) == EOF)<br>  <span class="hljs-keyword">break</span>;<br>    more--;<br>  &#125;<br>  <span class="hljs-keyword">return</span> n - more;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IO-doallocate：申请缓冲区并设置buf与read指针"><a href="#IO-doallocate：申请缓冲区并设置buf与read指针" class="headerlink" title="_IO_doallocate：申请缓冲区并设置buf与read指针"></a>_IO_doallocate：申请缓冲区并设置buf与read指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> _IO_file_doallocate (_IO_FILE *fp)<br>&#123;<br>  size = _IO_BUFSIZ;<span class="hljs-comment">//8192 bytes</span><br>  <span class="hljs-comment">//some options dealing with size……</span><br>  p = <span class="hljs-built_in">malloc</span> (size);<br>  <span class="hljs-comment">//set buf base and end</span><br>  _IO_setb (fp, p, p + size, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IO-new-file-overflow：建立并且刷新缓冲区"><a href="#IO-new-file-overflow：建立并且刷新缓冲区" class="headerlink" title="_IO_new_file_overflow：建立并且刷新缓冲区"></a>_IO_new_file_overflow：建立并且刷新缓冲区</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> _IO_new_file_overflow (_IO_FILE *f, <span class="hljs-type">int</span> ch)<br>&#123;<br>  <span class="hljs-comment">// If currently reading or no buffer allocated.</span><br>  <span class="hljs-keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="hljs-number">0</span> || f-&gt;_IO_write_base == <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    <span class="hljs-comment">//condition1：need a buffer</span><br>    <span class="hljs-keyword">if</span> (f-&gt;_IO_write_base == <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    <span class="hljs-comment">//alloc the buffer and set buf base/buf end</span><br>  _IO_doallocbuf (f);<br>  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);<br>  &#125;<br>    <span class="hljs-comment">//if read has done,put the read ptr at the buf begin</span><br>    <span class="hljs-keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)<br>    f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;<br>    <span class="hljs-comment">//the rest of buffer are used to write</span><br>    f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;<br>    f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;<br>    f-&gt;_IO_write_end = f-&gt;_IO_buf_end;<br>    f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;<br>    <br>    f-&gt;_flags |= _IO_CURRENTLY_PUTTING;<br>    <span class="hljs-keyword">if</span> (f-&gt;_mode &lt;= <span class="hljs-number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))<br>    f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;<br>  &#125;<br>  <span class="hljs-comment">//if the last char is EOF</span><br>  <span class="hljs-keyword">if</span> (ch == EOF)<br>    <span class="hljs-keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);<br>  <span class="hljs-comment">//buffer is full</span><br>  <span class="hljs-keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <br>    <span class="hljs-keyword">if</span> (_IO_do_flush (f) == EOF)<br>      <span class="hljs-keyword">return</span> EOF;<br>  *f-&gt;_IO_write_ptr++ = ch;<br>  <span class="hljs-keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED) || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="hljs-string">&#x27;\n&#x27;</span>))<br>    <span class="hljs-keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)<br>      <span class="hljs-keyword">return</span> EOF;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>) ch;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="new-do-write：调用输出系统调用"><a href="#new-do-write：调用输出系统调用" class="headerlink" title="new_do_write：调用输出系统调用"></a>new_do_write：调用输出系统调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span><br>_IO_size_t<br><span class="hljs-title function_">new_do_write</span> <span class="hljs-params">(_IO_FILE *fp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *data, _IO_size_t to_do)</span><br>&#123;<br>  _IO_size_t count;<br>  <span class="hljs-comment">//adjust the write pointer……</span><br>  count = _IO_SYSWRITE (fp, data, to_do);<br>  <span class="hljs-keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)<br>    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="hljs-number">1</span>, data, count) + <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//set all pointer at the begining</span><br>  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);<br>  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;<br>  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="hljs-number">0</span><br>       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))<br>       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);<br>  <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p>而对于<code>fwrite</code>而言，核心函数则是<code>_IO_xsputn</code>，该函数先尽力向缓冲区中加入用户需要输出的数据，所需输出的数据处于<code>_IO_write_base</code>和<code>_IO_write_ptr</code>之间，如果还是有待输出数据，则进行输出并刷新缓冲区，即运行<code>_IO_OVERFLOW</code>。<br>在该函数中，如果运行时文件还没有缓冲区，就建立一个缓冲区，但是，这时建立的缓冲区<code>_IO_write_end</code>为缓冲区的末尾；如果是一个存在缓冲区的文件进行<code>_IO_OVERFLOW</code>，则直接调用<code>new_do_write</code>。<br>简单来说<code>_IO_OVERFLOW</code>的前半部分负责输出缓冲区的初始化；<code>new_do_write</code>负责输出，并在输出后将输入指针和输出指针重置。  </p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/assets/fwrite.png" width="85%">    <br>    <div style="color:orange;    display: inline-block;    color: #999;    padding: 15px;">fwrite缓冲区操作</div></center><h2 id="reference"><a href="#reference" class="headerlink" title="reference:"></a>reference:</h2><blockquote><p>零基础要如何破除 IO_FILE 利用原理的迷雾 <a href="http://tttang.com/archive/1742/#toc_io_file">http://tttang.com/archive/1742/#toc_io_file</a><br>IO FILE之fread详解 <a href="https://www.anquanke.com/post/id/177958">https://www.anquanke.com/post/id/177958</a><br>glibc源码阅读 <a href="https://elixir.bootlin.com/glibc/glibc-2.36/source">https://elixir.bootlin.com/glibc/glibc-2.36/source</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>雪夜杂谈——Ptmalloc堆管理器分析</title>
    <link href="/2023/03/08/2023-3-8-Ptmalloc/"/>
    <url>/2023/03/08/2023-3-8-Ptmalloc/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>glibc的ptmalloc堆管理器的利用一直是CTF Pwn中的重点，但是其复杂性和利用方法的多样性让人难以理清“对于一个漏洞，到底需要怎么样的利用方法来实现getshell？”这种问题。<br>本文留作CTF赛前的复习资料，将会把<code>malloc</code>，<code>free</code>的过程以及检查点，漏洞利用点进行总结，以及近年以来的堆上保护措施的概览。为了更加清晰地展示<code>malloc</code>和<code>free</code>的变化，基础分析将从glibc-2.23开始。    </p><span id="more"></span><h2 id="一、malloc源码分析"><a href="#一、malloc源码分析" class="headerlink" title="一、malloc源码分析"></a>一、malloc源码分析</h2><p><code>malloc</code>函数的重要调用层次结构如下:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">__libc_malloc<br>            <span class="hljs-string">|----__malloc_hook</span><br>            <span class="hljs-string">|----_int_malloc</span><br>                        <span class="hljs-string">|----malloc_consolidate</span><br>                        <span class="hljs-string">|----sysmalloc</span><br></code></pre></td></tr></table></figure><p>这种划分方式能让我们更加清楚地知道需要分析的函数对象，但是<code>malloc</code>的分析中为了预测分配器行为，光是知道这些接口还不够，需要对其时序进行更加详细的分析。 </p><h3 id="1、-libc-malloc"><a href="#1、-libc-malloc" class="headerlink" title="1、__libc_malloc"></a>1、__libc_malloc</h3><p>在顶层（<code>__libc_malloc</code>）中，时序很简单，先观察<code>__malloc_hook</code>是否有记录，在hook执行完毕后执行内存分配的核心函数<code>_int_malloc</code>。  </p><h3 id="2、-int-malloc"><a href="#2、-int-malloc" class="headerlink" title="2、_int_malloc"></a>2、_int_malloc</h3><h4 id="2-1-fastbin分配"><a href="#2-1-fastbin分配" class="headerlink" title="2.1 fastbin分配"></a>2.1 fastbin分配</h4><p><code>fastbin</code>是<code>malloc</code>分配内存的最快途径，分配器检查申请大小处于<code>fastbin</code>的请求，找到对应的fastbin链表头，然后遍历该链表找到第一个可用的<code>fastbin chunck</code>，所以说，<code>fastbin</code>是LIFO的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (get_max_fast ()))<br>    &#123;<br>      idx = fastbin_index (nb);<br>      mfastbinptr *fb = &amp;fastbin (av, idx);<br>      mchunkptr pp = *fb;<br>      <span class="hljs-keyword">do</span><br>        &#123;<br>          victim = pp;<br>          <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>      <span class="hljs-keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))<span class="hljs-comment">//遍历fastbin链表</span><br>             != victim);<br></code></pre></td></tr></table></figure><p>该操作过后，如果能够够找到这样的堆块，对其进行检查然后返回，这里的检查主要是对于得到堆块大小进行检查，是否在其被取出的<code>fastbin</code>区间内。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="hljs-number">0</span>))<span class="hljs-comment">//检查fastbin大小</span><br>        &#123;<br>          <span class="hljs-comment">//malloc printerr...</span><br>        &#125;<br>      check_remalloced_chunk (av, victim, nb);<br>      <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>      alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而下方的<code>check_remalloced_chunk</code>只有开启了<code>MALLOC_DEBUG</code>才会存在，暂时不用管。  </p><h4 id="2-2-smallbin分配"><a href="#2-2-smallbin分配" class="headerlink" title="2.2 smallbin分配"></a>2.2 smallbin分配</h4><p>如果<code>fastbin</code>中没有找到分配对象，则在<code>smallbin</code>中寻找，与<code>fastbin</code>不同，<code>smallbin</code>为双链表，所以从链表尾部直接取即可，然后做一个解链的操作，将其从双链表中拆下，拆下之前要检查链表完整性，因为下面的解链操作用的是bin，所以不检查victim-&gt;fd-&gt;bk是否为victim本身。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>    &#123;<br>      idx = smallbin_index (nb);<br>      bin = bin_at (av, idx);<br><br>      <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin)<span class="hljs-comment">//从smallbin的队尾取堆块</span><br>        &#123;<br>          <span class="hljs-keyword">if</span> (victim == <span class="hljs-number">0</span>)<br>            malloc_consolidate (av);<br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              bck = victim-&gt;bk;<br><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>                &#123;<br>                  errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>                  <span class="hljs-keyword">goto</span> errout;<br>                &#125;<br>              set_inuse_bit_at_offset (victim, nb);<br>              bin-&gt;bk = bck;<br>              bck-&gt;fd = bin;<br><br>              <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                victim-&gt;size |= NON_MAIN_ARENA;<br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在从<code>smallbin</code>中找寻堆块之后还没结束，有两种情况：一种是，申请的大小不是<code>smallbin</code>之内的；另一种是目标<code>smallbin</code>中没有空闲堆块供分配。<br>这两种情况都会调用<code>malloc_consolidate</code>。<br>该函数遍历所有的<code>fastbin</code>链表，将其中所有的堆块放入<code>unsorted bin</code>中，腾出空间，在这中间，还需要对每个堆块进行合并。<br>对于前向（被合并的堆块在正在被分析的堆块的低地址处）合并，是以本堆块的<code>inuse bit</code>来判断的，<code>prev_size</code>来寻找的。<br>对于后向（被合并的堆块在正在被分析的堆块的高地址处）合并，是以下一个堆块的<code>inuse bit</code>来判断的，本堆块的<code>size</code>来寻找的。<br>如果有被合并的堆块，则需要调用<code>unlink</code>解链。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">malloc_consolidate</span><span class="hljs-params">(mstate av)</span><br>&#123;<br>    maxfb = &amp;fastbin (av, NFASTBINS - <span class="hljs-number">1</span>);<br>    fb = &amp;fastbin (av, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">do</span> &#123;<br>      p = atomic_exchange_acq (fb, <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">do</span> &#123;<br>  check_inuse_chunk(av, p);<br>  nextp = p-&gt;fd;<br><br>  size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);<br>  nextchunk = chunk_at_offset(p, size);<br>  nextsize = chunksize(nextchunk);<br>    <span class="hljs-comment">//检查向前（低地址处）是否有相邻的自由堆块</span><br>  <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>    prevsize = p-&gt;prev_size;<br>    size += prevsize;<br>    p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>    unlink(av, p, bck, fwd);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br>    <span class="hljs-comment">//检查向后（高地址处）是否有相邻的自由堆块</span><br>    <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>      size += nextsize;<br>      unlink(av, nextchunk, bck, fwd);<br>    &#125; <span class="hljs-keyword">else</span><br>      clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br><br>    first_unsorted = unsorted_bin-&gt;fd;<br>    unsorted_bin-&gt;fd = p;<br>    first_unsorted-&gt;bk = p;<br><br>    <span class="hljs-keyword">if</span> (!in_smallbin_range (size)) &#123;<br>      p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>      p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>      <span class="hljs-comment">//将合成后的堆块插入unsortedbin</span><br>    set_head(p, size | PREV_INUSE);<br>    p-&gt;bk = unsorted_bin;<br>    p-&gt;fd = first_unsorted;<br>    set_foot(p, size);<br>  &#125;<br><br>  <span class="hljs-keyword">else</span> &#123;<br>    size += nextsize;<br>    set_head(p, size | PREV_INUSE);<br>    av-&gt;top = p;<br>  &#125;<br><br>&#125; <span class="hljs-keyword">while</span> ( (p = nextp) != <span class="hljs-number">0</span>);<br><br>      &#125;<br>    &#125; <span class="hljs-keyword">while</span> (fb++ != maxfb);<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    malloc_init_state(av);<br>    check_malloc_state(av);<br>  &#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-3-unsorted-bin分配"><a href="#2-3-unsorted-bin分配" class="headerlink" title="2.3 unsorted bin分配"></a>2.3 unsorted bin分配</h4><p>接下来是一个无限大循环，大循环中第一个while循环是对<code>unsorted bin</code>的遍历，对于每个<code>unsorted bin</code>的元素，首先检查其是否为是否可以切割（切割最后一个，且为<code>last remainder</code>的堆块）。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<br>             bck == unsorted_chunks (av) &amp;&amp;<br>             victim == av-&gt;last_remainder &amp;&amp;<br>             (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>           &#123;<br>             <span class="hljs-comment">/* split and reattach remainder */</span><br>             remainder_size = size - nb;<br>             remainder = chunk_at_offset (victim, nb);<br>             unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<br>             av-&gt;last_remainder = remainder;<br>             remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>             <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>               &#123;<br>                 remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                 remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>               &#125;<br><br>             set_head (victim, nb | PREV_INUSE |<br>                       (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>             set_head (remainder, remainder_size | PREV_INUSE);<br>             set_foot (remainder, remainder_size);<br><br>             check_malloced_chunk (av, victim, nb);<br>             <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>             alloc_perturb (p, bytes);<br>             <span class="hljs-keyword">return</span> p;<br>           &#125;<br></code></pre></td></tr></table></figure><p>如果不能被切割，则从<code>unsorted bin</code>中解链，（这里的解链操作是存在问题的，没有校验完整性）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">unsorted_chunks (av)-&gt;bk = bck;<br>bck-&gt;fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure><p>接下来，如果堆块大小满足就直接返回，如果不满足，则按照其大小插入<code>smallbin</code>或者<code>largebin</code>，然后在堆管理的位图中标识即可。（此处插入依然没有校验完整性），此时插入<code>largebin</code>时除了<code>fd</code>和<code>bk</code>指针还要对<code>nextsize</code>指针进行处理。  </p><h3 id="2-4-largebin"><a href="#2-4-largebin" class="headerlink" title="2.4 largebin"></a>2.4 largebin</h3><p>现在终于到了在<code>largebin</code>中寻找的时候了，寻找适格堆块的方法就是按照size链表反向遍历。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size = chunksize (victim)) &lt;<br>                      (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb)))<br>                victim = victim-&gt;bk_nextsize;<br></code></pre></td></tr></table></figure><p>然后将目标解链，如果剩余的size合适，则作为<code>last remainder</code>放入<code>unsorted bin</code>，如果不是则将整个堆块保留。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c">remainder_size = size - nb;<br>              unlink (av, victim, bck, fwd);<br><br>              <span class="hljs-comment">/* Exhaust */</span><br>              <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>                &#123;<br>                  set_inuse_bit_at_offset (victim, size);<br>                  <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                    victim-&gt;size |= NON_MAIN_ARENA;<br>                &#125;<br>              <span class="hljs-comment">/* Split */</span><br>              <span class="hljs-keyword">else</span><br>                &#123;<br>                  remainder = chunk_at_offset (victim, nb);<br>                  <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                     have to perform a complete insert here.  */</span><br>                  bck = unsorted_chunks (av);<br>                  fwd = bck-&gt;fd;<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                    &#123;<br>                      errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;<br>                      <span class="hljs-keyword">goto</span> errout;<br>                    &#125;<br>                  remainder-&gt;bk = bck;<br>                  remainder-&gt;fd = fwd;<br>                  bck-&gt;fd = remainder;<br>                  fwd-&gt;bk = remainder;<br>                  <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                    &#123;<br>                      remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                      remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                    &#125;<br>                  set_head (victim, nb | PREV_INUSE |<br>                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                  set_head (remainder, remainder_size | PREV_INUSE);<br>                  set_foot (remainder, remainder_size);<br>                &#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-bitmap分配"><a href="#2-5-bitmap分配" class="headerlink" title="2.5 bitmap分配"></a>2.5 bitmap分配</h3><p>如果此时还没能分配，那么只能说明：申请的堆块如对应的bin以及<code>unsorted</code>中没有free的堆块，并且<code>unsorted bin</code>中的<code>last remainder</code>不符合申请的要求。这种情况下只能从更加大的bin中发现有无新的堆块。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c">   ++idx;<span class="hljs-comment">//更加大的index代表更大的bin，从第一个大于申请的bins开始找</span><br>   bin = bin_at (av, idx);<br>   block = idx2block (idx);<span class="hljs-comment">//找到描述idx所处的block，block用来索引该区块bins的位图</span><br>   <span class="hljs-built_in">map</span> = av-&gt;binmap[block];<span class="hljs-comment">//得到描述目标bin所在区域的位图</span><br>   bit = idx2bit (idx);<span class="hljs-comment">//得到目标bin对应的位图标识</span><br><br>   <span class="hljs-keyword">for</span> (;; )<br>     &#123;<br>       <br>       <span class="hljs-keyword">if</span> (bit &gt; <span class="hljs-built_in">map</span> || bit == <span class="hljs-number">0</span>)<span class="hljs-comment">//该区域没有合适的bin</span><br>         &#123;<br>           <span class="hljs-keyword">do</span><br>             &#123;<br>               <span class="hljs-keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="hljs-comment">//转换到下个区域</span><br>                 <span class="hljs-keyword">goto</span> use_top;<br>             &#125;<br>           <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">map</span> = av-&gt;binmap[block]) == <span class="hljs-number">0</span>);<br>           <span class="hljs-comment">//存在bins的区域</span><br>           bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));<br>           <span class="hljs-comment">//从该区域最小的开始找</span><br>           bit = <span class="hljs-number">1</span>;<br>         &#125;<br>       <span class="hljs-keyword">while</span> ((bit &amp; <span class="hljs-built_in">map</span>) == <span class="hljs-number">0</span>)<br>         &#123;<br>           bin = next_bin (bin);<br>           bit &lt;&lt;= <span class="hljs-number">1</span>;<br>           assert (bit != <span class="hljs-number">0</span>);<br>         &#125;<br>       victim = last (bin);<br><br>       <span class="hljs-comment">//记录错误，是空的bin</span><br>       <span class="hljs-keyword">if</span> (victim == bin)<br>         &#123;<br>           av-&gt;binmap[block] = <span class="hljs-built_in">map</span> &amp;= ~bit; <span class="hljs-comment">/* Write through */</span><br>           bin = next_bin (bin);<br>           bit &lt;&lt;= <span class="hljs-number">1</span>;<br>         &#125;<br>       <span class="hljs-keyword">else</span><br>         &#123;<br>           size = chunksize (victim);<br><br>           <span class="hljs-comment">/*  We know the first chunk in this bin is big enough to use. */</span><br>           assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb));<br><br>           remainder_size = size - nb;<br><br>           <span class="hljs-comment">/* unlink */</span><br>           unlink (av, victim, bck, fwd);<br><br>           <span class="hljs-comment">/* Exhaust */</span><br>           <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>             &#123;<br>               set_inuse_bit_at_offset (victim, size);<br>               <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                 victim-&gt;size |= NON_MAIN_ARENA;<br>             &#125;<br><br>           <span class="hljs-comment">/* Split */</span><br>           <span class="hljs-keyword">else</span><br>             &#123;<br>               remainder = chunk_at_offset (victim, nb);<br><br>               <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                  have to perform a complete insert here.  */</span><br>               bck = unsorted_chunks (av);<br>               fwd = bck-&gt;fd;<br><span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                 &#123;<br>                   errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;<br>                   <span class="hljs-keyword">goto</span> errout;<br>                 &#125;<br>               remainder-&gt;bk = bck;<br>               remainder-&gt;fd = fwd;<br>               bck-&gt;fd = remainder;<br>               fwd-&gt;bk = remainder;<br><br>               <span class="hljs-comment">/* advertise as last remainder */</span><br>               <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>                 av-&gt;last_remainder = remainder;<br>               <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                 &#123;<br>                   remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                   remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                 &#125;<br>               set_head (victim, nb | PREV_INUSE |<br>                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>               set_head (remainder, remainder_size | PREV_INUSE);<br>               set_foot (remainder, remainder_size);<br>             &#125;<br>           check_malloced_chunk (av, victim, nb);<br>           <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>           alloc_perturb (p, bytes);<br>           <span class="hljs-keyword">return</span> p;<br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-topchunk分配"><a href="#2-6-topchunk分配" class="headerlink" title="2.6 topchunk分配"></a>2.6 topchunk分配</h3><p>运行至此，如果还是没能分配，就说明bin里没有这么大的堆块，只能从<code>topchunk</code>上分割进行分配了。如果<code>top chunk</code>还不够大那么就利用<code>sysmalloc</code>向系统申请内存了。  </p><h2 id="二、free源码分析"><a href="#二、free源码分析" class="headerlink" title="二、free源码分析"></a>二、free源码分析</h2><p><code>free</code>函数的重要调用层次结构如下:</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__libc_free</span><br>            |----<span class="hljs-variable">__free_hook</span><br>            |----<span class="hljs-variable">_int_free</span><br></code></pre></td></tr></table></figure><p><code>free</code>的单线程活动部分比较简单，分为<code>fastbin</code>的释放和其它堆块释放两部分<br><code>fastbin</code>部分，将<code>fastbin chunk</code>放入对应bin的链表即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(size) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(get_max_fast ())<br>      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)) &#123;<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = fastbin_index(size);<br>    fb = &amp;fastbin (av, idx);<br><br>    mchunkptr old = *fb, old2;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> old_idx = ~<span class="hljs-number">0u</span>;<br>    <span class="hljs-keyword">do</span><br>      &#123;<br><span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>))<br>  &#123;<br>    errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br><span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span>)<br>  old_idx = fastbin_index(chunksize(old));<br>p-&gt;fd = old2 = old;<br>      &#125;<br>    <span class="hljs-keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);<br><br>    <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="hljs-number">0</span>))<br>      &#123;<br>errstr = <span class="hljs-string">&quot;invalid fastbin entry (free)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>其他部分，查看被释放堆块的前后有没有相邻的释放堆块进行合并  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>      prevsize = p-&gt;prev_size;<br>      size += prevsize;<br>      p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>      unlink(av, p, bck, fwd);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>      <span class="hljs-comment">/* get and clear inuse bit */</span><br>      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>      <span class="hljs-comment">/* consolidate forward */</span><br>      <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>unlink(av, nextchunk, bck, fwd);<br>size += nextsize;<br>      &#125; <span class="hljs-keyword">else</span><br>clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br>      bck = unsorted_chunks(av);<br>      fwd = bck-&gt;fd;<br>      <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>&#123;<br>  errstr = <span class="hljs-string">&quot;free(): corrupted unsorted chunks&quot;</span>;<br>  <span class="hljs-keyword">goto</span> errout;<br>&#125;<br>      p-&gt;fd = fwd;<br>      p-&gt;bk = bck;<br>      <span class="hljs-keyword">if</span> (!in_smallbin_range(size))<br>&#123;<br>  p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>  p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>&#125;<br>      bck-&gt;fd = p;<br>      fwd-&gt;bk = p;<br><br>      set_head(p, size | PREV_INUSE);<br>      set_foot(p, size);<br><br>      check_free_chunk(av, p);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      size += nextsize;<br>      set_head(p, size | PREV_INUSE);<br>      av-&gt;top = p;<br>      check_chunk(av, p);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>青梅煮酒——活跃变量分析</title>
    <link href="/2023/03/06/2023-3-6-DataFlowAnalyse/"/>
    <url>/2023/03/06/2023-3-6-DataFlowAnalyse/</url>
    
    <content type="html"><![CDATA[<h2 id="（一）目标"><a href="#（一）目标" class="headerlink" title="（一）目标"></a>（一）目标</h2><p>活跃变量分析可以分辨某个变量v的值在程序的p点之后会否再用到。即，是否存在一条路径从点p到结束点，使得变量v的值在v被重定义或者结束之前被用到。  </p><span id="more"></span><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/assets/livev.png">    <br>    <div style="color:orange;    display: inline-block;    color: #999;    padding: 15px;">活跃变量分析</div></center>  <h2 id="（二）对象以及调用过程分析"><a href="#（二）对象以及调用过程分析" class="headerlink" title="（二）对象以及调用过程分析"></a>（二）对象以及调用过程分析</h2><h3 id="1、Solver-IterativeSolver"><a href="#1、Solver-IterativeSolver" class="headerlink" title="1、Solver-&gt;IterativeSolver"></a>1、Solver-&gt;IterativeSolver</h3><p><code>Solver</code>是分析器的抽象表示，其中具体做出分析的类型为<code>DataflowAnalysis&lt;Node, Fact&gt;</code>类型，分析器的工作分为两个阶段：<strong>初始化</strong>和<strong>求解</strong>。<br><code>IterativeSolver</code>是更加具体细节的迭代分析器对象，其中完成了<code>doSolveForward</code>以及<code>doSolveBackward</code>的实现，在<code>doSolveBackward</code>中，我们实现活跃变量分析的代码即可。</p><h3 id="2、DataflowResult"><a href="#2、DataflowResult" class="headerlink" title="2、DataflowResult"></a>2、DataflowResult</h3><p>在《软件分析》课程讲述的算法中，对于每一个基本块都有一个IN，OUT集合，标示着“我们感兴趣”的静态分析问题的抽象。可以说，一个<code>DataflowResult</code>就是我们分析该问题的结果。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataflowResult</span>&lt;Node, Fact&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NodeResult</span>&lt;Node, Fact&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Node, Fact&gt; inFacts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Node, Fact&gt; outFacts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、Analysis"><a href="#3、Analysis" class="headerlink" title="3、Analysis"></a>3、Analysis</h3><p>Analysis是本次实验的核心部分，对于不同的分析，其Transfer Function与meet&#x2F;join操作都会有所不同，在迭代算法中，迭代求解器需要analysis的接口进行迭代操作。  </p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/assets/live_struct.png" width="70%">    <br>    <div style="color:orange;    display: inline-block;    color: #999;    padding: 15px;">框架概览</div></center><h2 id="（三）算法实现"><a href="#（三）算法实现" class="headerlink" title="（三）算法实现"></a>（三）算法实现</h2><p>算法理论部分如下</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/assets/live_algorithm.png" width="70%">    <br>    <div style="color:orange;    display: inline-block;    color: #999;    padding: 15px;">活跃变量迭代算法</div></center><h3 id="1、Transfer-function"><a href="#1、Transfer-function" class="headerlink" title="1、Transfer function"></a>1、Transfer function</h3><p>在活跃变量分析中，逻辑为反向的，举例而言，对于一个基本块<code>BasicBlock</code>，或者一个三地址表达式<code>Statement</code>，在其OUT中出现的变量，说明在这个基本块之后，执行结束（或者被redefine）之前，存在过use。而如果这些变量在该表达式中被定义，说明OUT之后的”use”承载的对象是刚刚赋值的。<br>所以有：$IN&#x3D;OUT-def$<br>但是如果在该块中def之前被使用过，那么在该块IN的位置依然还是活跃的。<br>所以有：$IN&#x3D;use\cup(OUT-def)$    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferNode</span><span class="hljs-params">(Stmt stmt, SetFact&lt;Var&gt; in, SetFact&lt;Var&gt; out)</span> &#123;<br>        <span class="hljs-comment">// TODO - finish me</span><br>        SetFact&lt;Var&gt; OldIn=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SetFact</span>&lt;&gt;();<br>        OldIn.set(in);<br>        in.union(out);<br>        <span class="hljs-keyword">if</span>(stmt.getDef().isPresent()) &#123;<br>            LValue lv=stmt.getDef().get();<br>            <span class="hljs-keyword">if</span>(lv <span class="hljs-keyword">instanceof</span> Var)&#123;<br>               in.remove((Var)lv);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(RValue rv:stmt.getUses())&#123;<br>           <span class="hljs-keyword">if</span>(rv <span class="hljs-keyword">instanceof</span> Var)&#123;<br>               in.add((Var)rv);<br>           &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (!in.equals(OldIn));<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2、meetInto"><a href="#2、meetInto" class="headerlink" title="2、meetInto"></a>2、meetInto</h3><p>对于活跃变量分析而言，因为其需要遵循Soundness的要求，即某个Statement的OUT处只要有一条路径能够让这个变量“存活”即可，所以一个Statement的OUT集合为其后继所有可能存活的变量的并集。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetInto</span><span class="hljs-params">(SetFact&lt;Var&gt; fact, SetFact&lt;Var&gt; target)</span> &#123;<br>        <span class="hljs-comment">// TODO - finish me</span><br>        target.union(fact);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、Solver"><a href="#3、Solver" class="headerlink" title="3、Solver"></a>3、Solver</h3><p>Solver实现的是迭代算法的最基本框架，在Solver中，遍历待分析程序的每一个基本块，对每一个基本块都进行meet+TransferFunction的操作，逐步迭代直至<code>DataflowResult</code>不发生改变为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSolveBackward</span><span class="hljs-params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;<br>        <span class="hljs-comment">// TODO - finish me</span><br>        <span class="hljs-type">boolean</span> IsChange=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">do</span>&#123;<br>            IsChange=<span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span>(Node node:cfg)&#123;<br>                <span class="hljs-keyword">if</span>(!cfg.isExit((node)))&#123;<br>                    <span class="hljs-keyword">var</span> succs=cfg.getSuccsOf(node);<br>                    <span class="hljs-keyword">for</span>(Node succ:succs)&#123;<br>                        analysis.meetInto(result.getInFact(succ),result.getOutFact(node));<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(analysis.transferNode(node, result.getInFact(node), result.getOutFact(node)))&#123;<br>                        IsChange=<span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(IsChange);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="4、Initialize"><a href="#4、Initialize" class="headerlink" title="4、Initialize"></a>4、Initialize</h3><p>其实只有知道了上述的实现过程，才有可能在理论上知道如何初始化，在最开始时，<code>DataflowResult</code>应该有“不安全”的结果，即，每一个基本块在输入端都是不活跃的，因为Soundness的要求，我们只能要求找出最保险的结果，即所有变量活跃。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SetFact&lt;Var&gt; <span class="hljs-title function_">newBoundaryFact</span><span class="hljs-params">(CFG&lt;Stmt&gt; cfg)</span> &#123;<br>    <span class="hljs-comment">// TODO - finish me</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetFact</span>&lt;&gt;();<br>&#125;<br><span class="hljs-keyword">public</span> SetFact&lt;Var&gt; <span class="hljs-title function_">newInitialFact</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// TODO - finish me</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetFact</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul><li>Q：Transfer Function 是否在偏序集中单增？<br>A：单增；<br>证明：<br>因为，IN&#x3D;use并(OUT-def)，其中use和def由程序本身确定，且不会改变；<br>所以，IN是否单增仅仅与OUT有关；<br>因为，初始化阶段，所有的IN被设为空集，而所有的OUT又是IN的并集；<br>所以，OUT最初的来源来自于各个基本块的use，而use中的元素是确定的，一旦进入集合，就无法被排除。<br>因此，后期再次因为集合操作进入OUT的元素，其归根到底来源于use，也无法被排除到集合之外。<br>综上，transferfunction单增。</li><li>Q：该算法是否能够停止？<br>A：能够停止；<br>因为Transfer Function单增，而IN，OUT集合在偏序集中有上界（程序中定义的所有变量都活跃），所以一定存在不动点使f(IN)&#x3D;IN，IN&#x2F;OUT没有变化，算法停止。  </li><li>Q：初始化阶段为何为空？<br>A：对于该问题，安全状态为“这个变量当前所储存的值在之后都可能被用到”（保证了所有变量值的可用），不安全状态为“这个变量当前所储存的值在之后没有可能被用到”，安全状态是确定的但是也是无用的，我们需要知道哪些变量的值之后都不可能用到了，所以只有从全部为空（不安全状态）开始，进行算法，算法停止时达到的不动点由于满足Transfer Function的设计而是安全的，且可以证明，该不动点为格上的最小不动点。  </li><li>Q：遍历顺序是否有关？<br>A：无关，遍历顺序只是改变了每一个格中元素向格上不动点前进的路径，达到的不动点本身都是一样的。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><p>基于南京大学软件分析课程的静态分析基础教程 <a href="https://static-analysis.cuijiacai.com/">https://static-analysis.cuijiacai.com/</a><br>”太阿“软件分析框架：<a href="https://tai-e.pascal-lab.net/">https://tai-e.pascal-lab.net/</a><br>软件分析-南京大学：<a href="https://www.bilibili.com/video/BV1b7411K7P4/">https://www.bilibili.com/video/BV1b7411K7P4/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>static analyse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>analyse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>雪夜杂谈——关于内核堆喷</title>
    <link href="/2023/01/30/2023-1-31-Heap-spary/"/>
    <url>/2023/01/30/2023-1-31-Heap-spary/</url>
    
    <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>  在用户态的单线程程序中，以ptmalloc为例，malloc函数分配的空间仅在该进程的用户空间中可见，堆块的申请和释放仅仅和本进程内部的malloc与free有关，只要进程对于堆块的操作和堆分配器的策略已知，那么在某一时刻堆分配的结构就是已知的。这样的性质对于用户态堆溢出和uaf的利用来说十分有帮助。  </p><span id="more"></span><p>当然，不排除在很多复杂的数据结构下，堆布局也存在着不同的困难，但是总体来说，用户态的对利用存在着不言自明的便利，例如，对于这样的指令序列：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-type">void</span>* b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br></code></pre></td></tr></table></figure><p>在进程的地址空间中，如果a，b分别是该进程申请的第一、第二个堆块，那么<strong>a与b堆块是相邻的</strong>，如果堆块a存在溢出，那么我们就会清楚地直到b堆块是被溢出堆块。而uaf的利用也是如此，例如对于以下序列：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-built_in">free</span>(a);<br>……<br><span class="hljs-type">void</span>* b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br></code></pre></td></tr></table></figure><p>如果a，b分别是该进程申请的第一、第二个堆块，那么<strong>a、b此时指向同一个堆块</strong>，如果a在free之后并没有置空，对a“堆块”的操作也就是在操作b堆块。<br>以上两种加粗的情况，就是CTF中堆利用最小、最简单普遍的构造布局，更加大型的布局例如heap overleap，house of 系列大都依赖着堆块分配策略的稳定性和确定性。然而，这点在内核pwn的过程却不能完全保证，存在以下几个原因：  </p><ul><li>exploit运行的过程中并不能覆盖全部申请堆块的进程</li><li>linux内核堆分配机制可以将不同进程、相同大小的堆块分配在一个slub中</li><li>不同的时刻，申请堆块时堆块来源的内存页可能不同</li></ul><p>所以在内核存在堆溢出和uaf时，我们需要提高运行exploit时达成特定堆布局的概率。以下引入内核堆喷射的方法。  </p><h2 id="二、slab堆喷与堆溢出混合使用"><a href="#二、slab堆喷与堆溢出混合使用" class="headerlink" title="二、slab堆喷与堆溢出混合使用"></a>二、slab堆喷与堆溢出混合使用</h2><p>既然需要在内核空间中达成特定的堆布局，我们就需要了解在内核<code>kmalloc/kfree</code>时的策略，该部分可以阅读源码或者在引用文献[1]中找到。<br>在运行exploit时，我们假设slab中总是半满（partial）的，即：当前cpu对应的slab中可用对象（freed object）和已分配对象（used object）交替分布，如图：  </p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/assets/ori_slab.png">    <br>    <div style="color:orange;    display: inline-block;    color: #999;    padding: 15px;">随机的slab布局</div></center>    <p>这时，在申请堆块时，<code>kmalloc</code>等函数返回堆块的地址杂乱并且相对关系不明，所以，我们需要构建<strong>新建空slab布局</strong>。堆喷射与堆溢出一起使用时，旨在<strong>大量申请目标大小堆块，将部分满（partial）的slab全部充满，迫使分配系统新建空slab，使得堆喷后，在空新建空slab上申请地址相对关系可预测。</strong><br>首先，在一个slab初始化时，slab中的内存分为两部分，一部分是内存对齐的对象，另一部分则是索引数组，所有对象都可用对象（freed object），索引数组递增排列，slab的<code>freelist</code>指向第一个索引，表示该slab的下一个可用对象为第一个对象（obj 0）。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/assets/empty_slab.png">    <br>    <div style="color:orange;    display: inline-block;    color: #999;    padding: 15px;">新建空slab布局</div></center>    <p>当对象从slab中拿出时，调用的是<code>slab_get_obj</code>，代码如下，可以看出是取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">slab_get_obj</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *cachep, <span class="hljs-keyword">struct</span> page *page)</span>&#123;<br>objp = index_to_obj(cachep, page, get_free_obj(page, page-&gt;active));<br>page-&gt;active++;<br><span class="hljs-keyword">return</span> objp;<br>&#125;<br></code></pre></td></tr></table></figure><p>在此时，如果拿出堆块a的地址为A_a，拿出堆块b的地址为A_b，则一定有：  A_a &lt; A_b</p><p>然而，“申请”的堆块与“拿出”的堆块不同，slab被拿出的对象只有放进cpu_cache才能够被<code>kmalloc</code>等接口返回，该过程<code>alloc_block</code>中，可以发现，cpu_cache中entry数组为栈结构，<code>avail</code>所指向的第一个可用对象是最后一个入栈元素。  </p><pre><code class="c">while (page-&gt;active &lt; cachep-&gt;num &amp;&amp; batchcount--) &#123;    //put objs into cpu cache    ac-&gt;entry[ac-&gt;avail++] = slab_get_obj(cachep, page);&#125;</code></pre><p>所以上述不等关系变为:A_a &gt; A_b<br>又因为对于所有<strong>新建空slab的连续申请</strong>，所以，只要在两次申请中间没有其它进程打断并申请同样大小的堆块，那么就有：A_a &#x3D; sizeof(object)+A_b<br>此时，如果堆块b存在堆溢出（一般堆喷结构体不存在主动溢出的情况），那么后申请的堆块b就可以溢出到堆喷所用的堆块a。  </p><h3 id="reference："><a href="#reference：" class="headerlink" title="reference："></a>reference：</h3><blockquote><p>[1]深入理解Linux内存管理（八）slab，slob和slub介绍  <a href="https://zhuanlan.zhihu.com/p/490588193">https://zhuanlan.zhihu.com/p/490588193</a><br>[2]2021 InCTF 题目地址 <a href="https://github.com/teambi0s/InCTFi/tree/master/">https://github.com/teambi0s/InCTFi/tree/master/</a><br>[3]InCTF 内核Pwn之 Kqueue <a href="https://bbs.kanxue.com/thread-269031.htm">https://bbs.kanxue.com/thread-269031.htm</a><br>[4]linux内核源码阅读 <a href="https://elixir.bootlin.com/linux/v5.16/source">https://elixir.bootlin.com/linux/v5.16/source</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kernel</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>雪夜杂谈——认识LKM</title>
    <link href="/2022/10/27/lkm/"/>
    <url>/2022/10/27/lkm/</url>
    
    <content type="html"><![CDATA[<h2 id="0、引子"><a href="#0、引子" class="headerlink" title="0、引子"></a>0、引子</h2><p>先说点小遗憾吧：笔者水平所限，关于linux是如何实现设备文件化以及如何实现LKM的没能深入探究，本节着重于「如何使用」的实用角度来了解LKM。后续如果笔者水平有所提高，会从更加细致的角度来进行探究。  </p><span id="more"></span><h2 id="1、LKM是什么"><a href="#1、LKM是什么" class="headerlink" title="1、LKM是什么"></a>1、LKM是什么</h2><p>LKM是Linux内核为了扩展其功能所使用的可加载内核模块。LKM的优点：动态加载，无须重新实现整个内核。基于此特性，LKM常被用作特殊设备的驱动程序（或文件系统），如声卡的驱动程序等等。<br>LKM内核模块属于ELF目标文件，但又区别于一般的应用程序，属于系统级别的程序，用来扩展Linux内核功能。通常使用LKM加载一些设备驱动，可以捕获系统调用，功能十分强大。<br><strong>注：LKM常用于做驱动程序，但是并非每个LKM都是驱动。</strong> 驱动代表操作设备的方式和流程，而LKM仅仅是内核动态加载的模块。<br>在Pwn过程中，出问题的地方大多都是LKM的代码，因为其运行在内核态，与内核，所以针对LKM的攻击可以在内核中实现很多结果，提权就是其中的一个目标。  </p><h2 id="2、LKM撰写及动态加载"><a href="#2、LKM撰写及动态加载" class="headerlink" title="2、LKM撰写及动态加载"></a>2、LKM撰写及动态加载</h2><p>我们从撰写一个典型的linux开始：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br>MODULE_LICENSE(<span class="hljs-string">&quot;Dual BSD/GPL&quot;</span>);<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ko_test_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123;<br>    printk(<span class="hljs-string">&quot;This is a test ko!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ko_test_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123;<br>    printk(<span class="hljs-string">&quot;Bye Bye~\n&quot;</span>);<br>&#125;<br>module_init(ko_test_init);<br>module_exit(ko_test_exit);<br></code></pre></td></tr></table></figure><p>其中module_init()是初始化函数，其在安装模块时被调用，所有的初始化工作可以在其中完成。module_exit()是清除函数，在卸载模块时调用。并且，我们用来输出字符产的函数是printk而不是printf。<br>在LKM中，是无法依赖于我们平时使用的C库的，<strong>模块仅仅被链接到内核</strong>，只可以调用内核所导出的函数，不存在可链接的函数库；这也是内核编程与我们平时应用程序编程的不同之一。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">KDIR =/usr/src/linux-headers-5.15.0-50-generic<br>obj-m += ko_test.o<br><span class="hljs-section">all:</span><br>        @<span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KDIR)</span> M=<span class="hljs-variable">$(PWD)</span> modules<br><br><span class="hljs-section">clean:</span><br>        rm -rf *.o *.ko *.mod.* *.symvers *.order<br></code></pre></td></tr></table></figure><p>这里的Makefile编写很有意思。<br>-C 选项的作用是指将当前工作目录转移到你所指定的位置。“M&#x3D;”选项的作用是，当用户需要以某个内核为基础编译一个外部模块的话，需要在make modules 命令中加入“M&#x3D;dir”，程序会自动到你所指定的dir目录中查找模块源码，将其编译，生成KO文件。所以我们是在内核文件夹下执行了make M&#x3D;$(PWD) modules。<br>编译完成后我们用root权限执行insmod加载驱动，利用rmmod移除驱动。  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift">emiya<span class="hljs-meta">@emiya</span><span class="hljs-operator">-</span>virtual<span class="hljs-operator">-</span>machine:<span class="hljs-operator">~/</span>桌面<span class="hljs-regexp">/KernelPwn/</span>ko$ make clean<br>rm <span class="hljs-operator">-</span>rf <span class="hljs-operator">*</span>.o <span class="hljs-operator">*</span>.ko <span class="hljs-operator">*</span>.mod<span class="hljs-operator">.*</span> <span class="hljs-operator">*</span>.symvers <span class="hljs-operator">*</span>.order<br>emiya<span class="hljs-meta">@emiya</span><span class="hljs-operator">-</span>virtual<span class="hljs-operator">-</span>machine:<span class="hljs-operator">~/</span>桌面<span class="hljs-regexp">/KernelPwn/</span>ko$ make<br>make <span class="hljs-operator">-</span><span class="hljs-type">C</span> <span class="hljs-regexp">/usr/</span>src<span class="hljs-regexp">/linux-headers-5.15.0-50-generic M=/</span>home<span class="hljs-regexp">/emiya/</span>桌面<span class="hljs-regexp">/KernelPwn/</span>ko modules<br>make[<span class="hljs-number">1</span>]: 进入目录“<span class="hljs-regexp">/usr/</span>src<span class="hljs-operator">/</span>linux<span class="hljs-operator">-</span>headers<span class="hljs-operator">-</span><span class="hljs-number">5.15</span>.<span class="hljs-number">0</span><span class="hljs-operator">-</span><span class="hljs-number">50</span><span class="hljs-operator">-</span>generic”<br>  <span class="hljs-type">CC</span> [<span class="hljs-type">M</span>]  <span class="hljs-regexp">/home/</span>emiya<span class="hljs-regexp">/桌面/</span><span class="hljs-type">KernelPwn</span><span class="hljs-regexp">/ko/</span>ko_test.o<br>  <span class="hljs-type">MODPOST</span> <span class="hljs-regexp">/home/</span>emiya<span class="hljs-regexp">/桌面/</span><span class="hljs-type">KernelPwn</span><span class="hljs-regexp">/ko/</span><span class="hljs-type">Module</span>.symvers<br>  <span class="hljs-type">CC</span> [<span class="hljs-type">M</span>]  <span class="hljs-regexp">/home/</span>emiya<span class="hljs-regexp">/桌面/</span><span class="hljs-type">KernelPwn</span><span class="hljs-regexp">/ko/</span>ko_test.mod.o<br>  <span class="hljs-type">LD</span> [<span class="hljs-type">M</span>]  <span class="hljs-regexp">/home/</span>emiya<span class="hljs-regexp">/桌面/</span><span class="hljs-type">KernelPwn</span><span class="hljs-regexp">/ko/</span>ko_test.ko<br>  <span class="hljs-type">BTF</span> [<span class="hljs-type">M</span>] <span class="hljs-regexp">/home/</span>emiya<span class="hljs-regexp">/桌面/</span><span class="hljs-type">KernelPwn</span><span class="hljs-regexp">/ko/</span>ko_test.ko<br><span class="hljs-type">Skipping</span> <span class="hljs-type">BTF</span> generation <span class="hljs-keyword">for</span> <span class="hljs-regexp">/home/</span>emiya<span class="hljs-regexp">/桌面/</span><span class="hljs-type">KernelPwn</span><span class="hljs-regexp">/ko/</span>ko_test.ko due to unavailability of vmlinux<br>make[<span class="hljs-number">1</span>]: 离开目录“<span class="hljs-regexp">/usr/</span>src<span class="hljs-operator">/</span>linux<span class="hljs-operator">-</span>headers<span class="hljs-operator">-</span><span class="hljs-number">5.15</span>.<span class="hljs-number">0</span><span class="hljs-operator">-</span><span class="hljs-number">50</span><span class="hljs-operator">-</span>generic”<br>emiya<span class="hljs-meta">@emiya</span><span class="hljs-operator">-</span>virtual<span class="hljs-operator">-</span>machine:<span class="hljs-operator">~/</span>桌面<span class="hljs-regexp">/KernelPwn/</span>ko$ sudo insmod ko_test.ko<br>emiya<span class="hljs-meta">@emiya</span><span class="hljs-operator">-</span>virtual<span class="hljs-operator">-</span>machine:<span class="hljs-operator">~/</span>桌面<span class="hljs-regexp">/KernelPwn/</span>ko$ sudo rmmod ko_test.ko<br>emiya<span class="hljs-meta">@emiya</span><span class="hljs-operator">-</span>virtual<span class="hljs-operator">-</span>machine:<span class="hljs-operator">~/</span>桌面<span class="hljs-regexp">/KernelPwn/</span>ko$ <br></code></pre></td></tr></table></figure><p>在另外的控制台利用<code>desmg -w</code>指令进行实时监视：  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[ 5818.816424]</span> This <span class="hljs-keyword">is</span> a test ko!<br><span class="hljs-string">[ 5826.482328]</span> Bye Bye~<br></code></pre></td></tr></table></figure><h2 id="3、为LKM传递参数"><a href="#3、为LKM传递参数" class="headerlink" title="3、为LKM传递参数"></a>3、为LKM传递参数</h2><p><strong>模块参数</strong>：简单来说模块参数允许用户再加载模块时通过命令行指定参数值，在模块的加载过程中，加载程序会得到命令行参数，并转换成相应类型的值，然后复制给对应的变量，这个过程发生在调用模块初始化函数之前。<br>在上一节之中的<code>ko_test.c</code>中加入如下代码，并且在<code>ko_test_init</code>中将其输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> baudrate = <span class="hljs-number">9600</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> port[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> *name = <span class="hljs-string">&quot;vser&quot;</span>;<br><br>module_param(baudrate,<span class="hljs-type">int</span>,S_IRUGO);<br>module_param_array(port,<span class="hljs-type">int</span>,<span class="hljs-literal">NULL</span>,S_IRUGO);<br>module_param(name,charp,S_IRUGO);<br></code></pre></td></tr></table></figure><p>我们看到<code>module_param</code>和<code>module_param_array</code>被用来声明可以命令行传递的参数，参数从头到尾分别为变量名，变量（或者数组元素）类型，（数组长度），文件类型。<br>我们可以在加载时直接用key&#x3D;value的方式进行传参：<br><code>sudo insmod ko_test.ko name=&quot;emiya&quot; port=1,6,6,6 baudrate=6666</code><br>结果如下，对比发现如果没有在加载时传参则显示默认的变量，如果传参则显示传递的参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[ <span class="hljs-number">9668.700714</span>] <span class="hljs-string">baudrate:9600</span><br>[ <span class="hljs-number">9668.700715</span>] <span class="hljs-number">0</span><br>[ <span class="hljs-number">9668.700716</span>] <span class="hljs-number">1</span><br>[ <span class="hljs-number">9668.700716</span>] <span class="hljs-number">2</span><br>[ <span class="hljs-number">9668.700716</span>] <span class="hljs-number">3</span><br><br>[ <span class="hljs-number">9668.700717</span>] <span class="hljs-attr">name:</span> <span class="hljs-string">vser</span><br>[ <span class="hljs-number">9877.239272</span>] <span class="hljs-string">Bye</span> <span class="hljs-string">Bye~</span><br>[ <span class="hljs-number">9928.136959</span>] <span class="hljs-string">init</span> <span class="hljs-string">module:hello</span> <span class="hljs-string">world!</span><br>                <br>[ <span class="hljs-number">9928.136961</span>] <span class="hljs-string">baudrate:6666</span><br>[ <span class="hljs-number">9928.136962</span>] <span class="hljs-number">1</span><br>[ <span class="hljs-number">9928.136963</span>] <span class="hljs-number">6</span><br>[ <span class="hljs-number">9928.136963</span>] <span class="hljs-number">6</span><br>[ <span class="hljs-number">9928.136963</span>] <span class="hljs-number">6</span><br><br>[ <span class="hljs-number">9928.136964</span>] <span class="hljs-attr">name:</span> <span class="hljs-string">emiya</span><br></code></pre></td></tr></table></figure><h2 id="4、接轨驱动"><a href="#4、接轨驱动" class="headerlink" title="4、接轨驱动"></a>4、接轨驱动</h2><h3 id="4-1-与内核交互"><a href="#4-1-与内核交互" class="headerlink" title="4.1 与内核交互"></a>4.1 与内核交互</h3><p>Linux就提供了一系列的系统调用，用来让开发者在用户态与系统沟通，进而与硬件沟通，其中就包括了我们常用的open、close、read、write和ioctl。<br>以<code>ioctl</code>为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ioctl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, ...)</span><br></code></pre></td></tr></table></figure><p>而陷入内核之后，ioctl的函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*ioctl)(<span class="hljs-keyword">struct</span> inode *node, <span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)<br></code></pre></td></tr></table></figure><p>ioctl变成了函数指针，fd被转换为两个结构体来标识节点和文件，用来标识操作的设备文件，cmd被原封不动的传入了驱动中。<br>我们来扩充一下我们的内核模块，在这时，我们可以叫它「驱动」了，因为它确实可以给我们提供访问设备文件的接口了。<br>首先是一些文件包含，以及我们要注册的设备类名，设备名，主设备号的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span> </span><br>MODULE_LICENSE(<span class="hljs-string">&quot;Dual BSD/GPL&quot;</span>);<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEVICE_NAME <span class="hljs-string">&quot;ko_test&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLASS_NAME <span class="hljs-string">&quot;ko_test&quot;</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> majorNumber;<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>   <span class="hljs-keyword">class</span>*  <span class="hljs-title">ko_test_class</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>   <span class="hljs-title">device</span>* <span class="hljs-title">ko_test_device</span> =</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>接下来，是我们自己定义的用于ioctl交互的函数，当用户态用ioctl操作我们注册的驱动文件时，将会调用此函数进行响应。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">ko_test_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> param)</span><br>&#123;<br>    <span class="hljs-keyword">switch</span>(cmd)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        &#123;<br>            printk(<span class="hljs-string">&quot;check ioctl 0\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span> :<br>            printk(<span class="hljs-string">&quot;unknown ioctl\n&quot;</span>);<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>file_operation就是把系统调用和驱动程序关联起来的关键数据结构。这个结构的每一个成员都对应着一个系统调用。读取file_operation中相应的函数指针，接着把控制权转交给函数，从而完成了Linux设备驱动程序的工作。</p><p>在系统内部，I&#x2F;O设备的存取操作通过特定的入口点来进行，而这组特定的入口点恰恰是由设备驱动程序提供的。通常这组设备驱动程序接口是由结构file_operations结构体向系统说明的，它定义在include&#x2F;linux&#x2F;fs.h中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">ko_test_options</span> =</span> &#123;<br>        .owner = THIS_MODULE,<br>        .unlocked_ioctl = ko_test_ioctl,<br>&#125;;<br></code></pre></td></tr></table></figure><p>从以下的初始化设备函数中，我们看到初始化设备的过程主要是以下三个函数：</p><ul><li>register_chrdev</li><li>class_create</li><li>device_create</li></ul><p><code>register_chrdev</code>向内核注册了一个字符设备。<br>第一个参数是主设备号，0代表动态分配,第二个参数是设备的名字，第三个参数是文件操作指针。<br><code>class_create</code>内核中定义了struct class结构体，顾名思义，一个struct class结构体类型变量对应一个类，内核同时提供了class_create函数，可以用它来创建一个类，这个类存放于sysfs下面，一旦创建好了这个类，再调用<code>device_create</code>函数来在&#x2F;dev目录下创建相应的设备节点。这样，加载模块的时候，用户空间中的udev会自动响应device_create函数，去&#x2F;sysfs下寻找对应的类从而创建设备节点。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ko_test_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123;<br>    printk(KERN_INFO <span class="hljs-string">&quot;Entering test module. \n&quot;</span>);<br>    majorNumber = register_chrdev(<span class="hljs-number">0</span>, DEVICE_NAME, &amp;ko_test_options);<br>    <span class="hljs-keyword">if</span>(majorNumber &lt; <span class="hljs-number">0</span>)&#123;<br>        printk(KERN_INFO <span class="hljs-string">&quot;Failed to register a major number. \n&quot;</span>);<br>        <span class="hljs-keyword">return</span> majorNumber;<br>    &#125;<br>    printk(KERN_INFO <span class="hljs-string">&quot;Successful to register a major number %d. \n&quot;</span>, majorNumber);<br>    ko_test_class = class_create(THIS_MODULE, CLASS_NAME);<br>    <span class="hljs-keyword">if</span>(IS_ERR(ko_test_class))<br>    &#123;<br>         unregister_chrdev(majorNumber, DEVICE_NAME);<br>         printk(KERN_INFO <span class="hljs-string">&quot;Class device register failed!\n&quot;</span>);<br>         <span class="hljs-keyword">return</span> PTR_ERR(ko_test_class);<br>    &#125;<br>    printk(KERN_INFO <span class="hljs-string">&quot;Class device register success!\n&quot;</span>);<br>    ko_test_device = device_create(ko_test_class, <span class="hljs-literal">NULL</span>, MKDEV(majorNumber, <span class="hljs-number">0</span>), <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;ko_test&quot;</span>);<br>    <span class="hljs-keyword">if</span> (IS_ERR(ko_test_device))<br>    &#123;<br>        class_destroy(ko_test_class);<br>        unregister_chrdev(majorNumber, DEVICE_NAME);<br>        printk(KERN_ALERT <span class="hljs-string">&quot;Failed to create the device\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> PTR_ERR(ko_test_device);<br>    &#125;<br>    printk(KERN_INFO <span class="hljs-string">&quot;Test module register successful. \n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ko_test_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123;<br>    printk(KERN_INFO <span class="hljs-string">&quot;Start to clean up module.\n&quot;</span>);<br>    device_destroy(ko_test_class, MKDEV(majorNumber, <span class="hljs-number">0</span>));<br>    class_destroy(ko_test_class);<br>    unregister_chrdev(majorNumber, DEVICE_NAME);<br>    printk(KERN_INFO <span class="hljs-string">&quot;Clean up successful. Bye.\n&quot;</span>);<br><br>&#125;<br>module_init(ko_test_init);<br>module_exit(ko_test_exit);<br></code></pre></td></tr></table></figure><p>编写简单的test.c程序打开设备文件并与其进行交互。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> fd;<br>        fd = open(<span class="hljs-string">&quot;/dev/ko_test&quot;</span>, O_RDWR); <span class="hljs-comment">//我们的设备挂载在/dev/test处</span><br>        <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>)&#123;<br>                perror(<span class="hljs-string">&quot;Failed to open the device...&quot;</span>);<br>                <span class="hljs-keyword">return</span> errno;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Open device successful!\n&quot;</span>);<br>        &#125;<br>        ioctl(fd, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Called ioctl with parameter 0!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs swift">emiya<span class="hljs-meta">@emiya</span><span class="hljs-operator">-</span>virtual<span class="hljs-operator">-</span>machine:<span class="hljs-operator">~/</span>桌面<span class="hljs-regexp">/KernelPwn/</span>ko$ make<br>make[<span class="hljs-number">1</span>]: 进入目录“<span class="hljs-regexp">/usr/</span>src<span class="hljs-operator">/</span>linux<span class="hljs-operator">-</span>headers<span class="hljs-operator">-</span><span class="hljs-number">5.15</span>.<span class="hljs-number">0</span><span class="hljs-operator">-</span><span class="hljs-number">50</span><span class="hljs-operator">-</span>generic”<br>  <span class="hljs-type">CC</span> [<span class="hljs-type">M</span>]  <span class="hljs-regexp">/home/</span>emiya<span class="hljs-regexp">/桌面/</span><span class="hljs-type">KernelPwn</span><span class="hljs-regexp">/ko/</span>ko_test.o<br>  <span class="hljs-type">MODPOST</span> <span class="hljs-regexp">/home/</span>emiya<span class="hljs-regexp">/桌面/</span><span class="hljs-type">KernelPwn</span><span class="hljs-regexp">/ko/</span><span class="hljs-type">Module</span>.symvers<br>  <span class="hljs-type">CC</span> [<span class="hljs-type">M</span>]  <span class="hljs-regexp">/home/</span>emiya<span class="hljs-regexp">/桌面/</span><span class="hljs-type">KernelPwn</span><span class="hljs-regexp">/ko/</span>ko_test.mod.o<br>  <span class="hljs-type">LD</span> [<span class="hljs-type">M</span>]  <span class="hljs-regexp">/home/</span>emiya<span class="hljs-regexp">/桌面/</span><span class="hljs-type">KernelPwn</span><span class="hljs-regexp">/ko/</span>ko_test.ko<br>  <span class="hljs-type">BTF</span> [<span class="hljs-type">M</span>] <span class="hljs-regexp">/home/</span>emiya<span class="hljs-regexp">/桌面/</span><span class="hljs-type">KernelPwn</span><span class="hljs-regexp">/ko/</span>ko_test.ko<br><span class="hljs-type">Skipping</span> <span class="hljs-type">BTF</span> generation <span class="hljs-keyword">for</span> <span class="hljs-regexp">/home/</span>emiya<span class="hljs-regexp">/桌面/</span><span class="hljs-type">KernelPwn</span><span class="hljs-regexp">/ko/</span>ko_test.ko due to unavailability of vmlinux<br>make[<span class="hljs-number">1</span>]: 离开目录“<span class="hljs-regexp">/usr/</span>src<span class="hljs-operator">/</span>linux<span class="hljs-operator">-</span>headers<span class="hljs-operator">-</span><span class="hljs-number">5.15</span>.<span class="hljs-number">0</span><span class="hljs-operator">-</span><span class="hljs-number">50</span><span class="hljs-operator">-</span>generic”<br>emiya<span class="hljs-meta">@emiya</span><span class="hljs-operator">-</span>virtual<span class="hljs-operator">-</span>machine:<span class="hljs-operator">~/</span>桌面<span class="hljs-regexp">/KernelPwn/</span>ko$ sudo insmod ko_test.ko<br>emiya<span class="hljs-meta">@emiya</span><span class="hljs-operator">-</span>virtual<span class="hljs-operator">-</span>machine:<span class="hljs-operator">~/</span>桌面<span class="hljs-regexp">/KernelPwn/</span>ko$ sudo <span class="hljs-operator">./</span>test<br><span class="hljs-type">Open</span> device successful<span class="hljs-operator">!</span><br><span class="hljs-type">Called</span> ioctl with parameter <span class="hljs-number">0</span><span class="hljs-operator">!</span><br>emiya<span class="hljs-meta">@emiya</span><span class="hljs-operator">-</span>virtual<span class="hljs-operator">-</span>machine:<span class="hljs-operator">~/</span>桌面<span class="hljs-regexp">/KernelPwn/</span>ko$ sudo <span class="hljs-operator">./</span>test<br><span class="hljs-type">Open</span> device successful<span class="hljs-operator">!</span><br><span class="hljs-type">Called</span> ioctl with parameter <span class="hljs-number">0</span><span class="hljs-operator">!</span><br>emiya<span class="hljs-meta">@emiya</span><span class="hljs-operator">-</span>virtual<span class="hljs-operator">-</span>machine:<span class="hljs-operator">~/</span>桌面<span class="hljs-regexp">/KernelPwn/</span>ko$ sudo <span class="hljs-operator">./</span>test<br><span class="hljs-type">Open</span> device successful<span class="hljs-operator">!</span><br><span class="hljs-type">Called</span> ioctl with parameter <span class="hljs-number">0</span><span class="hljs-operator">!</span><br>emiya<span class="hljs-meta">@emiya</span><span class="hljs-operator">-</span>virtual<span class="hljs-operator">-</span>machine:<span class="hljs-operator">~/</span>桌面<span class="hljs-regexp">/KernelPwn/</span>ko$ sudo <span class="hljs-operator">./</span>test<br><span class="hljs-type">Open</span> device successful<span class="hljs-operator">!</span><br><span class="hljs-type">Called</span> ioctl with parameter <span class="hljs-number">0</span><span class="hljs-operator">!</span><br></code></pre></td></tr></table></figure><p>同时desmg的消息如下，说明设备交互成功</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs smali">[ 4303.207265] Entering test module. <br>[ 4303.207270] Successful to register a major number 236. <br>[ 4303.207323] Class device register success!<br>[ 4303.207929] Test module register successful. <br>[ 4317.394714]<span class="hljs-built_in"> check </span>ioctl 0<br>[ 4319.625982]<span class="hljs-built_in"> check </span>ioctl 0<br>[ 4321.673908]<span class="hljs-built_in"> check </span>ioctl 0<br>[ 4322.504900]<span class="hljs-built_in"> check </span>ioctl 0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>kernel</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
